// utils/mergeContactDomains.js
//
// Merge ContactOut profile domain data into an existing CSV.  This
// helper reads the CSV (generated by the SignalHire scraper),
// matches rows by name and updates the `domain` column with the
// first business domain from each ContactOut profile.  Only one
// domain per row is stored.  If legacy domain1/domain2/domain3
// columns are present they are cleared.  If backup is enabled and the
// output file is the same as the input file, a `.bak` copy is
// written before modifications.  Returns the number of updated
// rows.

const fs = require('fs/promises');
const { parse } = require('csv-parse/sync');
const { stringify } = require('csv-stringify/sync');
const { cleanName } = require('./nameCleaner');

/**
 * Merge ContactOut domain data into a base CSV by matching on
 * full name, first name or last name.  Only the first domain
 * from each profile is used to populate the `domain` column.
 *
 * @param {Object} opts Options
 * @param {string} opts.baseCsvPath Path to the base CSV (required)
 * @param {Array<{fullName:string, firstName:string, lastName:string, domains:string[]}>} opts.contactProfiles ContactOut profiles to merge
 * @param {string} [opts.outPath=baseCsvPath] Path to write the merged CSV
 * @param {boolean} [opts.backup=false] Whether to create a backup file
 * @param {boolean} [opts.overwrite=false] Whether to overwrite existing domain values
 * @returns {Promise<{updated:number,total:number,outPath:string}>}
 */
async function mergeContactDomainsByNamePriority(opts) {
  const {
    baseCsvPath,
    contactProfiles,
    outPath = baseCsvPath,
    backup = false,
    overwrite = false,
  } = opts || {};
  if (!baseCsvPath) throw new Error('baseCsvPath is required');
  if (!Array.isArray(contactProfiles)) throw new Error('contactProfiles must be an array');
  // Read and parse the base CSV
  const raw = await fs.readFile(baseCsvPath);
  const rows = parse(raw, {
    columns: true,
    bom: true,
    skip_empty_lines: true,
    trim: true,
    // Allow records with fewer fields than the header.  Older CSVs may have
    // fewer columns (e.g. missing domain or Email).  Without this option
    // csv-parse will throw an error.  We normalise missing keys later.
    relax_column_count: true,
  });
  // Build indexes of ContactOut profiles keyed by normalised names
  const idxFull = new Map();
  const idxFirst = new Map();
  const idxLast = new Map();
  for (const p of contactProfiles) {
    const full = norm(cleanName(p.fullName));
    const first = norm(cleanName(p.firstName));
    const last = norm(cleanName(p.lastName));
    if (full) pushIdx(idxFull, full, p);
    if (first) pushIdx(idxFirst, first, p);
    if (last) pushIdx(idxLast, last, p);
  }
  const headers = Object.keys(rows[0] || {});
  const websiteKey = pickWebsiteHeader(headers);
  // Ensure the chosen Website/domain column exists on every row
  ensureWebsiteHeader(rows, websiteKey);
  const hget = mkHeaderGetter(headers);
  let updated = 0;
  for (const row of rows) {
    const fullName = hget(row, 'fullname') ?? hget(row, 'name') ?? hget(row, 'full_name') ?? hget(row, 'full name');
    const firstName = hget(row, 'firstname') ?? hget(row, 'first_name') ?? hget(row, 'first name') ?? hget(row, 'first');
    const lastName = hget(row, 'lastname') ?? hget(row, 'last_name') ?? hget(row, 'last name') ?? hget(row, 'last');
    const kFull = norm(cleanName(fullName || ''));
    const kFirst = norm(cleanName(firstName || ''));
    const kLast = norm(cleanName(lastName || ''));
    // Find matching profile by name priority: full > first > last
    let match = pickUnique(idxFull.get(kFull));
    if (!match && kFirst) match = pickUnique(idxFirst.get(kFirst));
    if (!match && kLast) match = pickUnique(idxLast.get(kLast));
    if (!match || !Array.isArray(match.domains) || match.domains.length === 0) continue;
    // Use only the first business domain
    const [d = ''] = match.domains;
    const k = websiteKey || 'Website';
    if (overwrite || !row[k]) row[k] = d;
    // If legacy domain1/domain2/domain3 columns exist, clear them
    if ('domain1' in row) row.domain1 = '';
    if ('domain2' in row) row.domain2 = '';
    if ('domain3' in row) row.domain3 = '';
    updated++;
  }
  // Optional backup when overwriting same file
  if (backup && outPath === baseCsvPath) {
    await fs.writeFile(baseCsvPath + '.bak', raw);
  }
  // Write back the CSV
  const outHeaders = Object.keys(rows[0] || {});
  const csv = stringify(rows, { header: true, columns: outHeaders, bom: true });
  await fs.writeFile(outPath, csv);
  console.log(`[MERGE] Updated ${updated}/${rows.length} rows -> ${outPath}`);
  return { updated, total: rows.length, outPath };
}

// ----- Helper functions -----
function norm(s) {
  return String(s || '')
    .toLowerCase()
    .replace(/\s+/g, ' ')
    .trim();
}
function pushIdx(map, key, v) {
  if (!key) return;
  const arr = map.get(key);
  if (arr) arr.push(v);
  else map.set(key, [v]);
}
function pickUnique(arr) {
  return Array.isArray(arr) && arr.length === 1 ? arr[0] : null;
}
function pickWebsiteHeader(headers) {
  const list = Array.isArray(headers) ? headers : [];
  const byLower = new Map(list.map((h) => [String(h).toLowerCase(), h]));
  // Prefer the new canonical header when present
  if (byLower.has('website')) return byLower.get('website');
  // Back-compat for older CSVs
  if (byLower.has('domain')) return byLower.get('domain');
  return null;
}

function ensureWebsiteHeader(rows, websiteKey) {
  if (!rows.length) return;
  const k = websiteKey || 'Website';
  for (const r of rows) {
    if (!Object.prototype.hasOwnProperty.call(r, k)) r[k] = '';
  }
}
function mkHeaderGetter(headers) {
  const map = new Map(headers.map((h) => [h.toLowerCase(), h]));
  return (row, key) => row[map.get(key)] ?? row[key];
}

module.exports = { mergeContactDomainsByNamePriority };