// utils/upgradeCsvAddEmailOnly.js
//
// Upgrade a CSV to ensure that an "Email" column exists.  When
// appending ContactOut data to a CSV generated by earlier runs
// which may not include an Email column, you must add the column
// before merging.  This helper reads the CSV, normalises column
// names, inserts an "Email" column in a sensible position and
// preserves other columns and order.  A backup is written if
// requested.  Returns an object describing whether changes were
// made and the final column order.

const fs = require('fs/promises');
const path = require('path');
const { parse } = require('csv-parse/sync');
const { stringify } = require('csv-stringify/sync');

const HEADERS_BASE = [
  'Name',
  'First Name',
  'Last Name',
  'Title',
  'Company',
  'Location',
  'LinkedIn URL',
];

function ciFind(headers, name) {
  const needle = String(name).toLowerCase();
  return headers.find((h) => String(h).toLowerCase() === needle);
}
function setCanonicalKey(row, canonical, alias) {
  if (canonical && Object.prototype.hasOwnProperty.call(row, canonical)) return;
  if (alias && Object.prototype.hasOwnProperty.call(row, alias)) {
    row[canonical] = row[alias];
    return;
  }
  row[canonical] = '';
}

/**
 * Rewrites the CSV to ensure columns: [BASEâ€¦, (domain1 if present), Email, <any other existing cols>].
 * Adds missing "Email" (empty values) and preserves BOM.  If the CSV
 * already has an "Email" header (case insensitive) nothing is done.
 *
 * @param {string} filePath Path to the CSV to upgrade
 * @param {Object} [opts]
 * @param {boolean} [opts.backup=true] Whether to write a .bak backup
 * @returns {Promise<{changed:boolean, columns?:string[], reason?:string}>}
 */
async function upgradeCsvAddEmailOnly(filePath, { backup = true } = {}) {
  const full = path.resolve(filePath);
  const raw = await fs.readFile(full);
  const rows = parse(raw, {
    columns: true,
    bom: true,
    trim: true,
    skip_empty_lines: true,
  });
  if (!rows.length) return { changed: false, reason: 'empty' };
  const headers = Object.keys(rows[0]);
  const d1Existing = ciFind(headers, 'domain1');
  const emailExisting = ciFind(headers, 'Email');
  const hasD1 = !!d1Existing;
  const hasMail = !!emailExisting;
  if (hasMail) {
    return { changed: false, reason: 'already-has-email' };
  }
  // Normalise rows so they have canonical "Email" key (copy from any variant)
  for (const r of rows) {
    setCanonicalKey(r, 'Email', emailExisting);
  }
  // Desired header order
  const wanted = [...HEADERS_BASE];
  if (hasD1) wanted.push(d1Existing);
  wanted.push('Email');
  // Append any other existing headers that we didn't list
  const wantedLower = new Set(wanted.map((h) => h.toLowerCase()));
  for (const h of headers) {
    if (!wantedLower.has(h.toLowerCase())) wanted.push(h);
  }
  // Stringify with BOM + exact header order we want
  const csv = stringify(rows, { header: true, columns: wanted, bom: true });
  if (backup) await fs.writeFile(full + '.bak', raw);
  await fs.writeFile(full, csv);
  return { changed: true, columns: wanted };
}

module.exports = { upgradeCsvAddEmailOnly };